# Хайпанём немножечко!
# Блокчейн (blockchain) переводится как «цепочка блоков».
# Это способ хранения данных, защищённый от подделки.
# Он лежит, например, в основе криптовалюты биткоин.
#
# Блокчейн — это действительно последовательность блоков,
# а в каждом блоке находится некоторая полезная информация.
# Так последовательность биткоина — список транзакций за определённый период времени:
# кто, кому, когда и сколько денег передал.
# Этот список снабжён случайным числом и некоторыми служебными данными,
# в том числе хэшем — числом, которое по определённой формуле зависит от остальной части блока и хэша предыдущего блока.
#
# Хэш должен быть меньше определённого числа.
# При этом формула, по которой вычисляется хэш, устроена так,
# что невозможно получить достаточно маленький хэш иначе, чем перебирая различные значения случайного числа.
# Поэтому если злоумышленник решит подделать блокчейн — например,
# вставить в его середину блок с записью о том,
# что все люди передали ему все свои деньги, — то столкнётся с проблемой.
# Ему придётся подобрать новое случайное число не только в поддельном блоке,
# но и во всех последующих, ведь хэш каждого следующего блока зависит от хэша предыдущего.
#
# Это требует невероятно больших вычислительных мощностей, поэтому блокчейн в целом защищён от подобных атак.
#
# Напишите программу, которая проводит проверку правильности хэшей в модельном блокчейне с простой хэш-функцией. Б
# лок bn с номером n включает полезную информацию mn,
# представленную натуральным числом, rn — случайное число от 0 до 255 и
# hn — хэш (целое число от 0 до 255). У каждого блока хэш вычисляется по формуле
# hn = 37 * (mn + rn + hn-1)(по модулю 256), при вычислении хэша начального блока
# h0 вместо хэша предыдущего блока берётся ноль. При этом каждый блок представлен одним числом
# bn = hn + rn * 256 + mn * 256^2. Также требуется, чтобы хэш hn был меньше 100.
blocks_count = int(input())
prev_hash = 0
invalid_block_number = -1

for i in range(blocks_count):
    block = int(input())
    r = (block // 256) % 256
    m = block // 256 ** 2
    current_hash = block % 256
    calculated_hash = (37 * (prev_hash + r + m)) % 256
    prev_hash = calculated_hash

    if invalid_block_number == -1 and (calculated_hash >= 100 or current_hash != calculated_hash):
        invalid_block_number = i

print(invalid_block_number)
