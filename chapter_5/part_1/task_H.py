# Шашки
# Шашки очень занимательная игра, которую достаточно легко моделировать.
#
# Правила подразумевают наличие двух классов: игральная доска и шашка.
# Однако мы немного упростим себе задачу и вместо шашки будем манипулировать клетками,
# которые могут находиться в трех состояниях: пустая, белая шашка и чёрная шашка.
#
# Разработайте два класса: Checkers и Cell.
#
# Объекты класса Checkers при инициализации строят игральную доску со стандартным распределением клеток
# и должны обладать методами:
#
# move(f, t) — перемещает шашку из позиции f в позицию t;
# get_cell(p) — возвращает объект «клетка» в позиции p.
# Объекты класса Cell при инициализации принимают одно из трех состояний: W — белая шашка, B — чёрная шашка,
# X — пустая клетка, а также обладают методом status() возвращающим заложенное в ней состояние.
#
# Координаты клеток описываются строками вида PQ, где:
#
# P — столбец игральной доски, одна из заглавных латинских букв: ABCDEFGH;
# Q — строка игральной доски, одна из цифр: 12345678.
# Будем считать, что пользователь всегда ходит правильно и контролировать возможность хода не требуется.
#
# Примечание
# Ваше решение должно содержать только классы и функции.
# В решении не должно быть вызовов инициализации требуемых классов.

class Checkers:

    def __init__(self):
        self.desk = {
            'A': {
                '8': 'X',
                '7': 'B',
                '6': 'X',
                '5': 'X',
                '4': 'X',
                '3': 'W',
                '2': 'X',
                '1': 'W',
            },
            'B': {
                '8': 'B',
                '7': 'X',
                '6': 'B',
                '5': 'X',
                '4': 'X',
                '3': 'X',
                '2': 'W',
                '1': 'X',
            },
            'C': {
                '8': 'X',
                '7': 'B',
                '6': 'X',
                '5': 'X',
                '4': 'X',
                '3': 'W',
                '2': 'X',
                '1': 'W',
            },
            'D': {
                '8': 'B',
                '7': 'X',
                '6': 'B',
                '5': 'X',
                '4': 'X',
                '3': 'X',
                '2': 'W',
                '1': 'X',
            },
            'E': {
                '8': 'X',
                '7': 'B',
                '6': 'X',
                '5': 'X',
                '4': 'X',
                '3': 'W',
                '2': 'X',
                '1': 'W',
            },
            'F': {
                '8': 'B',
                '7': 'X',
                '6': 'B',
                '5': 'X',
                '4': 'X',
                '3': 'X',
                '2': 'W',
                '1': 'X',
            },
            'G': {
                '8': 'X',
                '7': 'B',
                '6': 'X',
                '5': 'X',
                '4': 'X',
                '3': 'W',
                '2': 'X',
                '1': 'W',
            },
            'H': {
                '8': 'B',
                '7': 'X',
                '6': 'B',
                '5': 'X',
                '4': 'X',
                '3': 'X',
                '2': 'W',
                '1': 'X',
            },
        }

    def move(self, f, t):
        self.desk[f[0]][f[1]], self.desk[t[0]][t[1]] = self.desk[t[0]][t[1]], self.desk[f[0]][f[1]]

    def get_cell(self, p):
        return Cell(self.desk[p[0]][p[1]])


class Cell:

    def __init__(self, coordinates):
        self.coordinates = coordinates

    def status(self):
        return self.coordinates
